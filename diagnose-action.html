<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Action Diagnostic Tool</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        .input-group {
            margin: 20px 0;
            text-align: center;
        }
        input {
            background: #000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 10px;
            font-size: 16px;
            width: 200px;
            margin-right: 10px;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 10px #00ff00;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #output {
            background: #000;
            border: 1px solid #00ff00;
            padding: 15px;
            margin-top: 20px;
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }
        .error { color: #ff0000; }
        .success { color: #00ff00; }
        .warning { color: #ffff00; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç ACTION DIAGNOSTIC TOOL</h1>
        
        <div class="status" id="status">
            Connect your wallet and enter an action ID to diagnose
        </div>
        
        <div class="input-group">
            <input type="number" id="actionId" placeholder="Action ID (e.g., 66)" value="66">
            <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
            <button id="diagnoseBtn" onclick="diagnoseAction()" disabled>Run Diagnostic</button>
        </div>
        
        <div id="output">Waiting for diagnostic to run...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script>
        let provider, signer, stakingContract;
        const STAKING_CONTRACT_ADDRESS = '0x1cAcD190b8a9223f24F6aBFb7Ba6D598B3E513f0';
        const STAKING_ABI = [
            "function actions(uint256) view returns (uint8 actionType, uint256 newHourlyRewardRate, address[] pairs, uint256[] weights, address pairToAdd, string pairNameToAdd, string platformToAdd, uint256 weightToAdd, address pairToRemove, address recipient, uint256 withdrawAmount, bool executed, bool expired, uint8 approvals, address[] approvedBy, uint256 proposedTime, bool rejected)",
            "function REQUIRED_APPROVALS() view returns (uint256)",
            "function ADMIN_ROLE() view returns (bytes32)",
            "function hasRole(bytes32, address) view returns (bool)",
            "function hourlyRewardRate() view returns (uint256)",
            "function activePairs(uint256) view returns (address)",
            "function pairs(address) view returns (address lpToken, string pairName, string platform, uint256 weight, bool isActive)",
            "function estimateGas.executeAction(uint256)",
            "function callStatic.executeAction(uint256)"
        ];

        // Wait for ethers to load
        window.addEventListener('load', () => {
            if (typeof ethers === 'undefined') {
                log('‚ùå Ethers.js failed to load. Please refresh the page.', 'error');
                setStatus('Ethers.js library failed to load', 'error');
            } else {
                log('‚úÖ Ethers.js loaded successfully', 'success');
            }
        });

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            let prefix = '';
            
            if (type === 'error') prefix = '‚ùå ';
            else if (type === 'success') prefix = '‚úÖ ';
            else if (type === 'warning') prefix = '‚ö†Ô∏è ';
            else if (type === 'info') prefix = '‚ÑπÔ∏è ';
            
            output.textContent += `[${timestamp}] ${prefix}${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            document.getElementById('output').textContent = '';
        }

        function setStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        async function connectWallet() {
            try {
                clearLog();
                log('Connecting to wallet...', 'info');

                // Check if ethers is loaded
                if (typeof ethers === 'undefined') {
                    throw new Error('Ethers.js library not loaded. Please refresh the page.');
                }

                if (!window.ethereum) {
                    throw new Error('MetaMask not found. Please install MetaMask extension.');
                }

                log('Creating provider...', 'info');
                provider = new ethers.providers.Web3Provider(window.ethereum);

                log('Requesting account access...', 'info');
                await provider.send("eth_requestAccounts", []);

                signer = provider.getSigner();
                const address = await signer.getAddress();

                log('Creating contract instance...', 'info');
                stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, STAKING_ABI, signer);

                log(`Connected: ${address}`, 'success');
                log(`Contract: ${STAKING_CONTRACT_ADDRESS}`, 'success');

                setStatus('Wallet connected! Enter action ID and click "Run Diagnostic"', 'success');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('diagnoseBtn').disabled = false;

            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                setStatus('Connection failed', 'error');
                console.error('Full error:', error);
            }
        }

        async function diagnoseAction() {
            const actionId = parseInt(document.getElementById('actionId').value);
            
            if (isNaN(actionId) || actionId <= 0) {
                alert('Please enter a valid action ID');
                return;
            }
            
            clearLog();
            log('='.repeat(80));
            log(`DIAGNOSTIC FOR ACTION #${actionId}`);
            log('='.repeat(80));
            
            try {
                // 1. Contract connection
                log('\n1Ô∏è‚É£ CONTRACT CONNECTION', 'info');
                log('-'.repeat(80));
                log(`Contract Address: ${stakingContract.address}`, 'success');
                
                // 2. Action details
                log('\n2Ô∏è‚É£ ACTION DETAILS', 'info');
                log('-'.repeat(80));
                const action = await stakingContract.actions(actionId);
                log(`Action Type: ${action.actionType.toString()}`);
                log(`Approvals: ${action.approvals.toString()}`);
                log(`Executed: ${action.executed}`);
                log(`Rejected: ${action.rejected}`);
                log(`Expired (flag): ${action.expired}`);
                log(`Proposed Time: ${action.proposedTime.toString()}`);
                
                // 3. Approval requirements
                log('\n3Ô∏è‚É£ APPROVAL REQUIREMENTS', 'info');
                log('-'.repeat(80));
                const requiredApprovals = await stakingContract.REQUIRED_APPROVALS();
                log(`Required: ${requiredApprovals.toString()}`);
                log(`Current: ${action.approvals.toString()}`);
                const hasEnoughApprovals = action.approvals >= requiredApprovals;
                log(`Has enough: ${hasEnoughApprovals ? 'YES ‚úÖ' : 'NO ‚ùå'}`, hasEnoughApprovals ? 'success' : 'error');
                
                // 4. Time-based expiry
                log('\n4Ô∏è‚É£ TIME-BASED EXPIRY', 'info');
                log('-'.repeat(80));
                const currentBlock = await provider.getBlock('latest');
                const currentTime = currentBlock.timestamp;
                const proposedTime = parseInt(action.proposedTime.toString());
                const expiryTime = proposedTime + (7 * 24 * 60 * 60);
                const timeRemaining = expiryTime - currentTime;
                
                log(`Current Time: ${currentTime} (${new Date(currentTime * 1000).toISOString()})`);
                log(`Proposed Time: ${proposedTime} (${new Date(proposedTime * 1000).toISOString()})`);
                log(`Expiry Time: ${expiryTime} (${new Date(expiryTime * 1000).toISOString()})`);
                log(`Time Remaining: ${timeRemaining} seconds (${(timeRemaining / 3600).toFixed(2)} hours)`);
                const isExpired = currentTime > expiryTime;
                log(`Is Expired: ${isExpired ? 'YES ‚ùå' : 'NO ‚úÖ'}`, isExpired ? 'error' : 'success');
                
                // 5. Admin role
                log('\n5Ô∏è‚É£ ADMIN ROLE CHECK', 'info');
                log('-'.repeat(80));
                const signerAddress = await signer.getAddress();
                const adminRole = await stakingContract.ADMIN_ROLE();
                const hasAdminRole = await stakingContract.hasRole(adminRole, signerAddress);
                log(`Signer: ${signerAddress}`);
                log(`Has ADMIN_ROLE: ${hasAdminRole ? 'YES ‚úÖ' : 'NO ‚ùå'}`, hasAdminRole ? 'success' : 'error');
                
                // 6. Action-specific data
                log('\n6Ô∏è‚É£ ACTION-SPECIFIC DATA', 'info');
                log('-'.repeat(80));
                const actionTypes = ['SET_HOURLY_REWARD_RATE', 'UPDATE_PAIR_WEIGHTS', 'ADD_PAIR', 'REMOVE_PAIR', 'CHANGE_SIGNER', 'WITHDRAW_REWARDS'];
                const actionTypeName = actionTypes[action.actionType] || 'UNKNOWN';
                log(`Action Type: ${actionTypeName}`);
                
                if (action.actionType.toString() === '0') {
                    log(`New Rate: ${action.newHourlyRewardRate.toString()}`);
                    const currentRate = await stakingContract.hourlyRewardRate();
                    log(`Current Rate: ${currentRate.toString()}`);
                }
                
                // 7. Gas estimation
                log('\n7Ô∏è‚É£ GAS ESTIMATION', 'info');
                log('-'.repeat(80));
                try {
                    const gasEstimate = await stakingContract.estimateGas.executeAction(actionId);
                    log(`Gas Estimate: ${gasEstimate.toString()} ‚úÖ`, 'success');
                } catch (gasError) {
                    log(`Gas Estimation Failed ‚ùå`, 'error');
                    log(`Error: ${gasError.message}`, 'error');
                    
                    // Try static call
                    log('\nTrying static call for revert reason...');
                    try {
                        await stakingContract.callStatic.executeAction(actionId);
                        log('Static call succeeded (unexpected)', 'warning');
                    } catch (staticError) {
                        log(`Static call failed: ${staticError.message}`, 'error');
                        if (staticError.reason) {
                            log(`üîç REVERT REASON: ${staticError.reason}`, 'error');
                        }
                    }
                }
                
                // 8. Summary
                log('\n8Ô∏è‚É£ EXECUTION READINESS SUMMARY', 'info');
                log('='.repeat(80));
                
                const checks = [
                    ['Not executed', !action.executed],
                    ['Not rejected', !action.rejected],
                    ['Not expired (flag)', !action.expired],
                    ['Not expired (time)', !isExpired],
                    ['Has enough approvals', hasEnoughApprovals],
                    ['User has ADMIN_ROLE', hasAdminRole]
                ];
                
                let allPassed = true;
                checks.forEach(([check, passed]) => {
                    log(`${passed ? '‚úÖ' : '‚ùå'} ${check}`, passed ? 'success' : 'error');
                    if (!passed) allPassed = false;
                });
                
                log('\n' + '='.repeat(80));
                if (allPassed) {
                    log('‚úÖ ALL CHECKS PASSED - Action should be executable', 'success');
                    setStatus('All checks passed! Action should be executable.', 'success');
                } else {
                    log('‚ùå SOME CHECKS FAILED - Action cannot be executed', 'error');
                    setStatus('Some checks failed. See details above.', 'error');
                }
                log('='.repeat(80));
                
            } catch (error) {
                log(`\n‚ùå DIAGNOSTIC ERROR: ${error.message}`, 'error');
                setStatus('Diagnostic failed', 'error');
            }
        }
    </script>
</body>
</html>

