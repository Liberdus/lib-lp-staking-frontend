<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 2 Integration Test - Contract Integration & State Management</title>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/components.css">
    <style>
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .test-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: var(--liberdus-bg-secondary);
            border: 1px solid var(--liberdus-border-primary);
            border-radius: 0.5rem;
        }
        
        .test-title {
            color: var(--liberdus-text-primary);
            font-size: 1.25rem;
            font-weight: var(--liberdus-font-semibold);
            margin-bottom: 1rem;
        }
        
        .test-result {
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin: 0.5rem 0;
            font-family: var(--liberdus-font-mono);
            font-size: 0.875rem;
        }
        
        .test-success {
            background: var(--liberdus-green-bg);
            color: var(--liberdus-green);
            border: 1px solid var(--liberdus-green);
        }
        
        .test-error {
            background: var(--liberdus-red-bg);
            color: var(--liberdus-red);
            border: 1px solid var(--liberdus-red);
        }
        
        .test-info {
            background: var(--liberdus-blue-bg);
            color: var(--liberdus-blue);
            border: 1px solid var(--liberdus-blue);
        }
        
        .test-button {
            background: var(--liberdus-blue);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            margin: 0.25rem;
            font-size: 0.875rem;
        }
        
        .test-button:hover {
            background: var(--liberdus-blue-light);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-success { background: var(--liberdus-green); }
        .status-error { background: var(--liberdus-red); }
        .status-pending { background: var(--liberdus-orange); }
    </style>
</head>
<body>
    <div class="test-container">
        <h1 style="text-align: center; color: var(--liberdus-text-primary); margin-bottom: 2rem;">
            üß™ Day 2 Integration Test Suite
        </h1>
        <p style="text-align: center; color: var(--liberdus-text-secondary); margin-bottom: 3rem;">
            Contract Integration & State Management System Validation
        </p>
        
        <!-- ErrorHandler Tests -->
        <div class="test-section">
            <h2 class="test-title">üö® ErrorHandler System Tests</h2>
            <div id="error-handler-results"></div>
            <button class="test-button" onclick="testErrorHandler()">Test Error Handler</button>
            <button class="test-button" onclick="testErrorCategories()">Test Error Categories</button>
            <button class="test-button" onclick="testRetryLogic()">Test Retry Logic</button>
        </div>
        
        <!-- StateManager Tests -->
        <div class="test-section">
            <h2 class="test-title">üîÑ StateManager Observer Pattern Tests</h2>
            <div id="state-manager-results"></div>
            <button class="test-button" onclick="testStateManager()">Test State Management</button>
            <button class="test-button" onclick="testObserverPattern()">Test Observer Pattern</button>
            <button class="test-button" onclick="testComputedProperties()">Test Computed Properties</button>
        </div>
        
        <!-- EventManager Tests -->
        <div class="test-section">
            <h2 class="test-title">üì° EventManager Real-time Tests</h2>
            <div id="event-manager-results"></div>
            <button class="test-button" onclick="testEventManager()">Test Event Manager</button>
            <button class="test-button" onclick="testEventProcessing()">Test Event Processing</button>
            <button class="test-button" onclick="testEventSubscriptions()">Test Event Subscriptions</button>
        </div>
        
        <!-- ContractManager Tests -->
        <div class="test-section">
            <h2 class="test-title">üìú ContractManager Integration Tests</h2>
            <div id="contract-manager-results"></div>
            <button class="test-button" onclick="testContractManager()">Test Contract Manager</button>
            <button class="test-button" onclick="testProviderFallback()">Test Provider Fallback</button>
            <button class="test-button" onclick="testGasEstimation()">Test Gas Estimation</button>
        </div>
        
        <!-- Integration Tests -->
        <div class="test-section">
            <h2 class="test-title">üîó System Integration Tests</h2>
            <div id="integration-results"></div>
            <button class="test-button" onclick="testFullIntegration()">Test Full Integration</button>
            <button class="test-button" onclick="testErrorFlow()">Test Error Flow</button>
            <button class="test-button" onclick="testStateSync()">Test State Synchronization</button>
        </div>
        
        <!-- Overall Status -->
        <div class="test-section" style="border: 2px solid var(--liberdus-blue);">
            <h2 class="test-title">üìä Overall Test Status</h2>
            <div id="overall-status">
                <div class="test-info">Click "Run All Tests" to validate Day 2 implementation</div>
            </div>
            <button class="test-button" onclick="runAllTests()" style="background: var(--liberdus-green); font-weight: bold;">
                üöÄ Run All Tests
            </button>
            <button class="test-button" onclick="clearResults()">Clear Results</button>
        </div>
    </div>

    <!-- Load Day 2 Systems -->
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="js/core/error-handler.js"></script>
    <script src="js/core/state-manager.js"></script>
    <script src="js/core/event-manager.js"></script>
    <script src="js/contracts/contract-manager.js"></script>

    <script>
        // Test Results Storage
        const testResults = {
            errorHandler: [],
            stateManager: [],
            eventManager: [],
            contractManager: [],
            integration: []
        };

        // Utility Functions
        function addResult(category, test, status, message) {
            const result = { test, status, message, timestamp: Date.now() };
            testResults[category].push(result);
            updateDisplay(category);
        }

        function updateDisplay(category) {
            const container = document.getElementById(`${category.replace('Manager', '-manager')}-results`);
            const results = testResults[category];
            
            container.innerHTML = results.map(result => {
                const statusClass = result.status === 'success' ? 'test-success' : 
                                  result.status === 'error' ? 'test-error' : 'test-info';
                const statusIcon = result.status === 'success' ? '‚úÖ' : 
                                 result.status === 'error' ? '‚ùå' : '‚ÑπÔ∏è';
                
                return `<div class="${statusClass}">${statusIcon} ${result.test}: ${result.message}</div>`;
            }).join('');
        }

        // ErrorHandler Tests
        async function testErrorHandler() {
            try {
                // Test error processing
                const testError = new Error('Test error message');
                testError.code = 'INSUFFICIENT_FUNDS';
                
                const processedError = window.errorHandler.processError(testError, { test: true });
                
                if (processedError.category === 'blockchain' && processedError.userMessage.title === 'Insufficient Funds') {
                    addResult('errorHandler', 'Error Processing', 'success', 'Error correctly categorized and processed');
                } else {
                    addResult('errorHandler', 'Error Processing', 'error', 'Error processing failed');
                }
                
                // Test error display
                const notification = window.errorHandler.displayError(processedError);
                if (notification && notification.type === 'error') {
                    addResult('errorHandler', 'Error Display', 'success', 'Error notification created successfully');
                } else {
                    addResult('errorHandler', 'Error Display', 'error', 'Error display failed');
                }
                
            } catch (error) {
                addResult('errorHandler', 'ErrorHandler Test', 'error', error.message);
            }
        }

        async function testErrorCategories() {
            const testCases = [
                { error: new Error('network error'), expectedCategory: 'network' },
                { error: { code: 'USER_REJECTED' }, expectedCategory: 'wallet' },
                { error: new Error('execution reverted'), expectedCategory: 'contract' }
            ];
            
            let passed = 0;
            for (const testCase of testCases) {
                const processed = window.errorHandler.processError(testCase.error);
                if (processed.category === testCase.expectedCategory) {
                    passed++;
                }
            }
            
            if (passed === testCases.length) {
                addResult('errorHandler', 'Error Categories', 'success', `All ${testCases.length} categories correctly identified`);
            } else {
                addResult('errorHandler', 'Error Categories', 'error', `Only ${passed}/${testCases.length} categories correct`);
            }
        }

        async function testRetryLogic() {
            let attempts = 0;
            const maxAttempts = 3;
            
            try {
                await window.errorHandler.executeWithRetry(async () => {
                    attempts++;
                    if (attempts < maxAttempts) {
                        throw new Error('Temporary failure');
                    }
                    return 'success';
                }, { test: true }, { maxRetries: maxAttempts - 1 });
                
                if (attempts === maxAttempts) {
                    addResult('errorHandler', 'Retry Logic', 'success', `Retry logic worked correctly (${attempts} attempts)`);
                } else {
                    addResult('errorHandler', 'Retry Logic', 'error', `Unexpected attempt count: ${attempts}`);
                }
            } catch (error) {
                addResult('errorHandler', 'Retry Logic', 'error', error.message);
            }
        }

        // StateManager Tests
        async function testStateManager() {
            try {
                // Test basic state operations
                window.stateManager.set('test.value', 'hello');
                const value = window.stateManager.get('test.value');
                
                if (value === 'hello') {
                    addResult('stateManager', 'Basic State Operations', 'success', 'Set/get operations working correctly');
                } else {
                    addResult('stateManager', 'Basic State Operations', 'error', `Expected 'hello', got '${value}'`);
                }
                
                // Test nested state
                window.stateManager.set('nested.deep.value', 42);
                const nestedValue = window.stateManager.get('nested.deep.value');
                
                if (nestedValue === 42) {
                    addResult('stateManager', 'Nested State', 'success', 'Nested state operations working');
                } else {
                    addResult('stateManager', 'Nested State', 'error', `Expected 42, got ${nestedValue}`);
                }
                
            } catch (error) {
                addResult('stateManager', 'StateManager Test', 'error', error.message);
            }
        }

        async function testObserverPattern() {
            try {
                let observerCalled = false;
                let observedValue = null;
                
                // Subscribe to state changes
                const unsubscribe = window.stateManager.subscribe('observer.test', (newValue) => {
                    observerCalled = true;
                    observedValue = newValue;
                });
                
                // Change state
                window.stateManager.set('observer.test', 'observer-value');
                
                // Small delay to ensure observer is called
                await new Promise(resolve => setTimeout(resolve, 10));
                
                if (observerCalled && observedValue === 'observer-value') {
                    addResult('stateManager', 'Observer Pattern', 'success', 'Observer notifications working correctly');
                } else {
                    addResult('stateManager', 'Observer Pattern', 'error', `Observer not called or wrong value: ${observedValue}`);
                }
                
                unsubscribe();
            } catch (error) {
                addResult('stateManager', 'Observer Pattern', 'error', error.message);
            }
        }

        async function testComputedProperties() {
            try {
                // Define computed property
                window.stateManager.computed('computed.fullName', (state) => {
                    const first = state.computed?.firstName || '';
                    const last = state.computed?.lastName || '';
                    return `${first} ${last}`.trim();
                }, ['computed.firstName', 'computed.lastName']);
                
                // Set dependencies
                window.stateManager.set('computed.firstName', 'John');
                window.stateManager.set('computed.lastName', 'Doe');
                
                // Small delay for computed property update
                await new Promise(resolve => setTimeout(resolve, 10));
                
                const fullName = window.stateManager.get('computed.fullName');
                
                if (fullName === 'John Doe') {
                    addResult('stateManager', 'Computed Properties', 'success', 'Computed properties working correctly');
                } else {
                    addResult('stateManager', 'Computed Properties', 'error', `Expected 'John Doe', got '${fullName}'`);
                }
                
            } catch (error) {
                addResult('stateManager', 'Computed Properties', 'error', error.message);
            }
        }

        // EventManager Tests
        async function testEventManager() {
            try {
                if (window.eventManager) {
                    const status = window.eventManager.getQueueStatus();
                    addResult('eventManager', 'EventManager Initialization', 'success', `EventManager loaded, queue length: ${status.queueLength}`);
                } else {
                    addResult('eventManager', 'EventManager Initialization', 'error', 'EventManager not found');
                }
            } catch (error) {
                addResult('eventManager', 'EventManager Test', 'error', error.message);
            }
        }

        async function testEventProcessing() {
            try {
                // Test event queueing
                window.eventManager.queueEvent('TestEvent', { test: true, timestamp: Date.now() });
                
                const status = window.eventManager.getQueueStatus();
                if (status.queueLength > 0) {
                    addResult('eventManager', 'Event Processing', 'success', 'Event queuing working correctly');
                } else {
                    addResult('eventManager', 'Event Processing', 'error', 'Event not queued properly');
                }
            } catch (error) {
                addResult('eventManager', 'Event Processing', 'error', error.message);
            }
        }

        async function testEventSubscriptions() {
            try {
                let eventReceived = false;
                
                // Subscribe to test events
                const unsubscribe = window.eventManager.addEventListener('TestSubscription', (eventData) => {
                    eventReceived = true;
                });
                
                // Trigger event
                window.eventManager.notifyEventListeners('TestSubscription', { test: true });
                
                if (eventReceived) {
                    addResult('eventManager', 'Event Subscriptions', 'success', 'Event subscriptions working correctly');
                } else {
                    addResult('eventManager', 'Event Subscriptions', 'error', 'Event subscription not triggered');
                }
                
                unsubscribe();
            } catch (error) {
                addResult('eventManager', 'Event Subscriptions', 'error', error.message);
            }
        }

        // ContractManager Tests
        async function testContractManager() {
            try {
                if (window.contractManager) {
                    const health = await window.contractManager.getProviderHealth();
                    if (health.error) {
                        addResult('contractManager', 'ContractManager Health', 'info', `ContractManager loaded but not connected: ${health.error}`);
                    } else {
                        addResult('contractManager', 'ContractManager Health', 'success', `ContractManager healthy, network: ${health.networkId}`);
                    }
                } else {
                    addResult('contractManager', 'ContractManager Test', 'error', 'ContractManager not found');
                }
            } catch (error) {
                addResult('contractManager', 'ContractManager Test', 'error', error.message);
            }
        }

        async function testProviderFallback() {
            try {
                const fallbackCount = window.contractManager.fallbackProviders.length;
                const canUseFallback = window.contractManager.canUseFallbackProvider();
                
                addResult('contractManager', 'Provider Fallback', 'success', 
                    `${fallbackCount} fallback providers configured, can use fallback: ${canUseFallback}`);
            } catch (error) {
                addResult('contractManager', 'Provider Fallback', 'error', error.message);
            }
        }

        async function testGasEstimation() {
            try {
                // Test gas estimation utility exists
                if (typeof window.contractManager.estimateGasWithBuffer === 'function') {
                    addResult('contractManager', 'Gas Estimation', 'success', 'Gas estimation methods available');
                } else {
                    addResult('contractManager', 'Gas Estimation', 'error', 'Gas estimation methods not found');
                }
            } catch (error) {
                addResult('contractManager', 'Gas Estimation', 'error', error.message);
            }
        }

        // Integration Tests
        async function testFullIntegration() {
            try {
                // Test system integration
                const systems = ['errorHandler', 'stateManager', 'eventManager', 'contractManager'];
                const loadedSystems = systems.filter(system => window[system]);
                
                if (loadedSystems.length === systems.length) {
                    addResult('integration', 'System Integration', 'success', 'All Day 2 systems loaded and integrated');
                } else {
                    const missing = systems.filter(system => !window[system]);
                    addResult('integration', 'System Integration', 'error', `Missing systems: ${missing.join(', ')}`);
                }
            } catch (error) {
                addResult('integration', 'Full Integration', 'error', error.message);
            }
        }

        async function testErrorFlow() {
            try {
                // Test error flow through systems
                const testError = new Error('Integration test error');
                const processed = window.errorHandler.processError(testError, { integration: true });
                
                if (processed.id && processed.category && processed.userMessage) {
                    addResult('integration', 'Error Flow', 'success', 'Error flow through systems working');
                } else {
                    addResult('integration', 'Error Flow', 'error', 'Error flow incomplete');
                }
            } catch (error) {
                addResult('integration', 'Error Flow', 'error', error.message);
            }
        }

        async function testStateSync() {
            try {
                // Test state synchronization
                window.stateManager.set('integration.test', 'sync-test');
                const value = window.stateManager.get('integration.test');
                
                if (value === 'sync-test') {
                    addResult('integration', 'State Synchronization', 'success', 'State synchronization working');
                } else {
                    addResult('integration', 'State Synchronization', 'error', 'State sync failed');
                }
            } catch (error) {
                addResult('integration', 'State Synchronization', 'error', error.message);
            }
        }

        // Run All Tests
        async function runAllTests() {
            clearResults();
            
            const startTime = Date.now();
            
            // Run all test categories
            await testErrorHandler();
            await testErrorCategories();
            await testRetryLogic();
            
            await testStateManager();
            await testObserverPattern();
            await testComputedProperties();
            
            await testEventManager();
            await testEventProcessing();
            await testEventSubscriptions();
            
            await testContractManager();
            await testProviderFallback();
            await testGasEstimation();
            
            await testFullIntegration();
            await testErrorFlow();
            await testStateSync();
            
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            // Calculate overall results
            const allResults = Object.values(testResults).flat();
            const successCount = allResults.filter(r => r.status === 'success').length;
            const errorCount = allResults.filter(r => r.status === 'error').length;
            const totalCount = allResults.length;
            
            const overallStatus = document.getElementById('overall-status');
            const successRate = Math.round((successCount / totalCount) * 100);
            
            let statusClass = 'test-success';
            let statusMessage = `üéâ All tests passed! (${successCount}/${totalCount})`;
            
            if (errorCount > 0) {
                statusClass = successRate >= 80 ? 'test-info' : 'test-error';
                statusMessage = `‚ö†Ô∏è ${successCount}/${totalCount} tests passed (${successRate}% success rate)`;
            }
            
            overallStatus.innerHTML = `
                <div class="${statusClass}">
                    ${statusMessage}
                    <br>Duration: ${duration}ms
                    <br>Errors: ${errorCount}
                </div>
            `;
        }

        function clearResults() {
            Object.keys(testResults).forEach(category => {
                testResults[category] = [];
                updateDisplay(category);
            });
            
            document.getElementById('overall-status').innerHTML = 
                '<div class="test-info">Click "Run All Tests" to validate Day 2 implementation</div>';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Day 2 Integration Test Suite loaded');
            
            // Check if all systems are available
            const systems = ['errorHandler', 'stateManager', 'eventManager', 'contractManager'];
            const loadedSystems = systems.filter(system => window[system]);
            
            console.log('Loaded systems:', loadedSystems);
            console.log('Missing systems:', systems.filter(system => !window[system]));
        });
    </script>
</body>
</html>
